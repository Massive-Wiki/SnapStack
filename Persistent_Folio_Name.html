<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Persistent Folio Name - SnapStack</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="//markpub-static/css/style.css">
    <link rel="stylesheet" href="//markpub-static/css/custom.css">
    <link rel="stylesheet" href="https://unpkg.com/bluesky-comments@0.9.0/dist/bluesky-comments.css">
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/lunr.js/2.3.9/lunr.min.js"></script>
    <script src="//lunr-index-1761088055.391386.js"></script>
    <script>var index = lunr.Index.load(lunr_index)</script>
    
    
    <script src="//lunr-posts-1761088055.391386.js"></script>
    <script> function randomPageLink() { return "/"+lunr_posts[Math.floor(Math.random() * lunr_posts.length)].link; } </script>
    
  </head>
<body>
  <div id="header">
    <span id="hamburger-btn"
    class="hidden">&#9776;</span><a class="button is-light" id="header-link" href="//index.html">SnapStack</a>
  </div>

  <div class="container" id="flex-container">
    <div id="side-column">
      <div>
        <button id="hide-btn">Hide</button>
        <button id="move-btn" class="hidden">Move to Sidebar</button>
      </div>
      <h3>Site Navigation</h3>
<div class="navlinks">
<ul>
<li><a href="/">HOME</a></li>
<li><a href="//search.html">SEARCH</a></li>
<li><a href="//all-pages.html">ALL PAGES</a></li>
<li><a href="//recent-pages.html">RECENT CHANGES</a></li>
</ul>
</div>
<div class="navlinks">
  <button onclick="location.href=`${randomPageLink()}`">
    RANDOM PAGE
  </button>
</div>

    </div>

    <div id="main-column">
      
      <div> <!-- edit this page button -->
	<p style="float:right; margin:.5em .5em
	.5em"><a target="_blank" href="https://github.com/Massive-Wiki/SnapStack/edit/main/Persistent Folio Name.md"
	class="edit-this-page-button">Edit on GitHub</a></p>
	<br clear="all">
      </div> <!-- edit this page button -->
      
      <h1>Persistent Folio Name</h1>
<p><em>This page was mostly written by Claude Sonnet 4.5 in 2025-10, under the supervision of Peter Kaminski. Peter Kaminski takes responsiblity for its content.</em></p>
<p>For your information, the page <a class="wikilink" href="//IPNS_name.html">IPNS name</a> is a bridge from early SnapStack documents that use that phrase and the newer discussion here of "Persistent Folio Name".</p>
<h2>The Persistent Name Goal, and IPNS Solution</h2>
<p>Content-addressed systems like IPFS generate new hashes whenever content changes. For mutable websites or applications, this means the address changes with every update. IPNS (InterPlanetary Name System) was designed to solve this by providing persistent addresses that point to changing content, but implementing reliable IPNS in practice reveals significant operational challenges.</p>
<h2>The IPNS Republishing Problem</h2>
<p>IPNS records expire and require periodic republishing (typically every 24 hours). Unlike IPFS content pinning, which has mature infrastructure and commercial services, IPNS republishing services are scarce. The IPNS record itself must be actively maintained by a node that has the private key, creating an availability requirement that contradicts IPFS's goal of decentralized persistence.</p>
<p>Standard IPFS pinning services don't solve this. They keep your content available but don't handle IPNS republishing. You can pin content at <code>/ipfs/Qm...</code> but your <code>/ipns/k51...</code> pointer still needs active republishing.</p>
<h2>Current Solutions</h2>
<h3>1. Self-Hosted Persistent Node</h3>
<p>Run your own IPFS node that stays online 24/7 and handles IPNS republishing automatically.</p>
<p><strong>Pros:</strong></p>
<ul>
<li>Full control</li>
<li>No third-party dependencies</li>
<li>Free (after infrastructure costs)</li>
</ul>
<p><strong>Cons:</strong></p>
<ul>
<li>Requires persistent infrastructure (VPS, home server, etc.)</li>
<li>Monitoring and maintenance overhead</li>
<li>Single point of failure unless you implement redundancy</li>
<li>Must secure the IPNS private key</li>
</ul>
<p><strong>Publisher ease: Low</strong> | <strong>Persistence: Medium</strong> | <strong>Management: High</strong></p>
<h3>2. w3name</h3>
<p>Web3.Storage's IPNS republishing service provides managed IPNS records.</p>
<p><strong>Pros:</strong></p>
<ul>
<li>Managed service handles republishing</li>
<li>API-driven updates</li>
<li>No infrastructure to maintain</li>
</ul>
<p><strong>Cons:</strong></p>
<ul>
<li>Single vendor dependency</li>
<li>Service continuity risk</li>
<li>API integration required</li>
<li>Potential costs or rate limits</li>
</ul>
<p><strong>Publisher ease: Medium</strong> | <strong>Persistence: Medium</strong> | <strong>Management: Low</strong></p>
<h3>3. DNSLink</h3>
<p>Use a TXT record in DNS to point to IPFS content. Format: <code>dnslink=/ipfs/Qm...</code> or <code>dnslink=/ipns/k51...</code></p>
<p><strong>Pros:</strong></p>
<ul>
<li>Leverages existing DNS infrastructure</li>
<li>Mature, well-understood technology</li>
<li>Many DNS providers and automation options</li>
<li>Can be automated via DNS APIs</li>
<li>Human-readable addresses (your.domain instead of hashes)</li>
</ul>
<p><strong>Cons:</strong></p>
<ul>
<li>Requires domain ownership</li>
<li>DNS centralization (registrar and nameserver dependencies)</li>
<li>Not truly decentralized</li>
<li>Propagation delays (though typically seconds to minutes)</li>
<li>Annual domain renewal</li>
</ul>
<p><strong>Publisher ease: High</strong> | <strong>Persistence: High</strong> | <strong>Management: Low</strong></p>
<h3>4. ENS (Ethereum Name Service)</h3>
<p>Blockchain-based naming system that can point to IPFS content via contenthash records.</p>
<p><strong>Pros:</strong></p>
<ul>
<li>Decentralized and censorship-resistant</li>
<li>No servers to maintain</li>
<li>Human-readable names (yourname.eth)</li>
<li>Record updates are permanent until changed</li>
</ul>
<p><strong>Cons:</strong></p>
<ul>
<li>Requires Ethereum wallet and ETH for gas fees</li>
<li>Transaction costs for every update</li>
<li>Learning curve for blockchain interaction</li>
<li>Requires ENS-compatible tools/browsers or gateways</li>
<li>Annual ENS name renewal (blockchain transaction)</li>
</ul>
<p><strong>Publisher ease: Low</strong> | <strong>Persistence: High</strong> | <strong>Management: Medium</strong></p>
<h2>The Reality: No Perfect Solution</h2>
<p>Each approach sacrifices something:</p>
<ul>
<li><strong>Self-hosted nodes</strong> give control but require constant maintenance</li>
<li><strong>w3name</strong> reduces management but introduces vendor lock-in</li>
<li><strong>DNSLink</strong> is practical but defeats decentralization</li>
<li><strong>ENS</strong> is decentralized but adds cost and complexity</li>
</ul>
<p>For most publishers prioritizing ease and persistence over ideological purity, <strong>DNSLink emerges as the pragmatic choice</strong>. It uses boring, reliable DNS infrastructure and can be automated with any DNS provider's API. Yes, it's centralizedâ€”but it's centralized on infrastructure that already exists, that you already understand, and that has decades of operational maturity.</p>
<p>For projects where decentralization is paramount and costs are acceptable, <strong>ENS</strong> provides the most decentralized option, though updates require blockchain transactions.</p>
<p>The uncomfortable truth is that truly decentralized, low-maintenance, easy-to-use persistent addressing remains unsolved. IPNS was the vision, but its execution requires infrastructure that undermines its goals. The ecosystem isn't ready or widely available yet. Until IPNS republishing becomes as commoditized as content pinning, we're left choosing which compromises we can tolerate.</p>
<h2>Practical Recommendation</h2>
<p><strong>For most use cases:</strong> Start with DNSLink using a DNS provider with API support (Cloudflare, Route53, etc.). Automate updates via CI/CD or deployment scripts. Accept the DNS centralization as a reasonable tradeoff.</p>
<p><strong>For decentralization-critical projects:</strong> Use ENS and budget for gas fees. Implement update batching to minimize transaction costs.</p>
<p><strong>If vendor lock-in is acceptable:</strong> w3name provides the easiest managed IPNS option, assuming the service remains available.</p>
<p><strong>Only if you have ops capacity:</strong> Run your own IPFS nodes with monitoring, backups, and ideally geographic redundancy.</p>
<p>The state of the art is, as of late 2025, still evolving. Persistent addressing in decentralized systems is harder than it looks.</p>

      
      <hr>
      <div>
	<h4>Pages that link to this page</h4>
	<ul>
	  
	  <li><a href="//IPNS_name.html">IPNS name</a>
	  
	</ul>
      </div>
      
    </div>
  </div>
  
  <footer class="footer">
  <div class="content has-text-centered">
    
    <div><strong>SnapStack</strong> by the Massive Wiki Team.</div>
    
    
    <div>Central repository at <a href="https://github.com/Massive-Wiki/SnapStack">SnapStack</a>.</div>
    
    
    <div>Licensed under <a href="http://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a>.</div>
    
    <div><em>Site last updated on Tuesday, October 21, 2025 at 23:07 UTC.</em></div>
  </div>
</footer>
</body>
</html>